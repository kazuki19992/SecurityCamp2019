
回答ID
396
確認番号
110406
希望するゼミ
Y-Ⅰ OS開発ゼミ
自由記載解答欄
----共通問題A----

私は、普段私用のPCでWindowsとUbuntuを使用しており、大学ではMacOSXを使用している。スマートフォンではAndroidを使用している。

普段使用しているUbuntuの好きなところは大きく分けて2点である。
・自由に様々な部分をカスタマイズできる。
・使用できるソフトウェアの数が多い
私は実際にGUIやシェルを自分で使いやすくカスタマイズした。見た目はモチベーションに直結するのでGUIテーマやプロンプトも自分で調べながら変更した。それ以外にもランチャーなどの拡張機能をインストールして、使いやすくした。カスタマイズしている段階でコマンドなどわからない点が出てきた場合はその都度調べたり、知人のエンジニアや大学の先輩に相談したりして解決した。それにより、自分の理想の環境を作り上げることができたほか、Linuxについて理解を深めることができた。
私がUbuntuを入れる直前までは「Windowsほど使えるソフトも多くはないだろうし、何か作業をする上でWindowsを使う必要があるかもしれないな」と考えていた。しかし、環境構築をしている過程でUbuntuのソフトウェアセンターを覗いてみたり、Webで調べていたりするうちに必要としているVScodeやChromeなどのソフトウェアはLinux版も公開されていたりオープンソースのソフトウェアで代替することができることに気づいた。また、どうしてもWindowsのソフトウェアを使う必要が出てきた場合はWineを使って起動することもできることも知って衝撃を受けた。WindowsからUbuntuに乗り換えてからソフトウェアで困ったことがない。

続いてUbuntuについて改善してほしいと考えている点だが、現状では具体的な改善点が見つかるほど使いこなせておらず、何をするにも調べながらであり、調べながら試行錯誤して目的を達成することがものすごく楽しいので、特に改善点は思い浮かばなかった。強いて言うとすれば、Windowsほどやりたいことが直感的にできないことだろうか。コマンド操作をすることがWindowsを使用していた頃と比べて圧倒的に多くなったため、Webで調べながらコマンド操作をすることが多くなった。しかし、先述の通り、調べながら操作し、なんとか目的を達成することが楽しいと感じているため、改善点とは言えないのかもしれない。回答になっていなかったら申し訳ない。

続いて、Windowsについてだ。Windowsの好きな点、改善してほしい点を述べていこうと思う。
Windowsの好きな点
・基本的にGUIの直感的な操作で完結することが多く、使いやすい
・多くの人が使っているOSのため、情報が豊富
Windowsはものすごく使いやすい。私もメインのPCでは現在もWindowsを使用しているし、大学に持ち運んでいるノートPCも以前はWindowsを使用していた。基本的な操作から多少複雑な操作までコマンドプロンプトなどの端末画面に一切触れずにGUIで目的の操作を達成できてしまうのでものすごく使いやすいと感じる。
しかし、それでもわからない点が出てくる場合がある。そのときは多くの情報が助けてくれる。その情報の多さもWindowsの魅力だと感じており、過去に何度もその情報に助けられている。現在、大学のヘルプデスクのアルバイトをしており、学生のPCを診ることが多いが、Windowsである場合がほとんどであるため、もしわからないことがあっても調べれば出てくる場合が多いという安心感がある。

続いて、Windowsの改善点だが、大きく2点ある。
・見た目を大きく変えることが難しい
・マルウェアが多い
前者の「見た目を大きく変えることが難しい」であるが、Windowsはオープンソースではないため、ユーザがGUIなどのテーマを大きく変更することは難しいと考えている。Windowsではシステムで使用するフォントを変えたり、GUIの色を変えたり、Windows7風のスタートボタン/スタートメニューを設置することしかカスタマイズできなかった。
後者は、過去に何度もマルウェアに自分のPCが汚染されており、その都度駆除を行ったという過去があるため、改善点に挙げた。最初の感染は中学生の頃だった。Webでいかがわしいサイトを閲覧してしまい、感染したと思われる。ある時、私はPCの動作が重いことに気づいた。当時スクリプトでウイルスもどきを作って遊んでいた私は、ウイルス感染を疑い、ブラウザでウイルス対策ソフトをダウンロードしようとした。しかし、トレンドマイクロやノートンなどのウイルス対策ソフトのページの他、Microsoftのページにもアクセスができなくなっていた。ウイルスを入れてしまったことが親にバレてしまうと怒られるので、なんとか自力で対処しようとした。そこで思いついたのが、当時使っていたWindows7に入っていたWindows XP mode(仮想マシン)を使った駆除方法だ。当時は仮想マシンの詳しい仕組みはわからなかったが、Windows7の中で別のWindowsが動いているということだけは理解していた。当時は「PCの中に別なPCがある」と考えていた。XP modeでIEを起動し、「ウイルス対策ソフト インストール不要」と検索し、McAfeeのポータブル版のページを開くことに成功した。「これでようやく怒られずにウイルスを消せる」と安心したと同時に、ウイルスは仮想マシンの中身には影響を与えないということも理解した。そのページからソフトをダウンロードして、Googleドライブにアップロードした。ホストPC側に戻ってGoogleドライブから先程アップロードしたソフトをダウンロード後起動し、PCのスキャンを実行したらかなりの量のウイルスが検出され、駆除された。その後、PCは正常に使えるようになり、親にもバレることはなかった。

Androidの好きなところ、改善してほしいところについてだ。
好きなところ
・ホームアプリを変更することでジェスチャー機能などを使用することができる
・ウィジェット機能でアプリを開かずとも情報を確認することができる
これはUbuntuの好きなところで述べたことと多少かなさる点ではあるが、ホームアプリを変更することで、デフォルトのホームアプリでは使用できないジェスチャー機能などを使用して、アプリを起動したり、アプリ内の機能にショートカットしたりすることができる。また、デフォルトのホームアプリでも可能だが、ウィジェットをホーム画面上に配置することでアプリを開かずとも情報を確認することができる。使いやすいように自由ホーム画面や項目の大きさ等様々な箇所を変更することが可能なところがAndroidで気に入っているところだ。
続いて、改善してほしい箇所だが、iOSのようにその端末専用のOSというわけではなく、いろいろな端末にインストールできる(最近PCにもインストールできることを知った)ため、その端末に最適化されているわけではないということだと考える。多少スペックの低いスマートフォンだと、Twitterなどのアプリを何個か開くだけで端末が発熱してフリーズしてしまうことがある。また、稀にアプリの動作が不安定になってしまうことがあり、OS ごと再起動となってしまうことがある。私はよくスマートフォンを目覚しに使用しているのだが、寝ている間にAndroidが再起動してしまい、翌朝アラームが鳴動せずに起きられなかったことがある。それ以来スマートフォンとAmazon Echoの2つのデバイスでアラームを冗長化している。

最後に、大学で使用しているMacOSXについてである。
大学では、演習用の環境としてiMacをシンクライアント運用しており、NetBoot機能を用い、学科の演習サーバ上にあるMacOSをネットワーク越しに起動している。
MacOSの好きなところは2点ある。
・UNIXであること
・文字が読みやすい
MacはUNIXであるため、Linuxと同じコマンド、同じシェルを使用することができる。そのおかげで、自分のUbuntu環境とかなり似ている環境を作ることができる。また、何かわからないことがあってもLinux用の情報を応用させることができるため、情報も多い。これはUbuntuを普段から使用しているときも感じており、先程と逆にMac用の情報をUbuntuに応用することもできるため、今以上にLinux初心者だった頃、コマンドを調べるときやシェルを変更するときなどにMac用の情報を参考にして解決したことがある。
MacOSはWindowsやUbuntuと比較してGUIがきれいだと感じることが多い。
特にフォントがきれいに表示されるため、とても読みやすく、Windowsと比較して長時間記事を読んでいたりプログラミングをしていても目が疲れにくくなったと感じる。大学のMacOSXは古いバージョンなのだが、最新のバージョンではダークモードが追加されているため、今以上に文字が読みやすくなると考えている。後学期からはMacの機器更新とともに、最新バージョンになるため、とても楽しみにしている。
続いて、MacOSの改善してほしいところだ。
・ショートカットキーがWindowsと異なっているところ
これは初めてMacOSを触ったときに感じた。ブラウザの更新がF5キーでできなかったのだ。Windowsのキーバインドが標準だとは思っていないが、何かの規格で定められているものだと考えていた。調べてみるとCommon User Accessという標準規格が存在し、Windowsの他、Unixなどにも実装されていると知った。Macの場合、Command+Rで更新が行えることを知り、WindowsでもCtrl+Rで更新できることを知った。CommandとCtrlは場所がほぼ同じであるため、WindowsのCtrlキーの機能をCommandキーに割り当てているのだと考えた。しかし、普段F5で更新しているため、Command+Rでは少し使いにくいと感じた。そのため、Webで調べると、ショートカットキーを変更する方法が見つかったため、Webページなどの更新をF5に割り当てて対応した。


----共通問題B----

私がOSを作るとしたら、以下の機能がほしいと考えている。
・GUIのテーマやシェルをカスタマイズできる
・最初はシンプルな構成で、拡張機能やアプリケーションをインストールすることで自分の好きな機能を利用できる
私は先述の通り、自分の使いやすいようにOSを変更するのが好きなので、最初はあえてシンプルな構成(USBなどを扱えるようにする, インターネットに繋げられるようにする等)にして、自分の好きな機能をインストールしてOSを作り上げていけるようにしたいと考えている。また、GUIのテーマやシェルを自由にカスタムできるような自由度の高いOSを作りたいと考えている。自分で好きなように自由に変更することは楽しく、わくわくできると考えているので上記のようなOSを作りたいと考えている。


----共通問題C----

--------C.1

// 共通問題C
// C言語で双方向リンクリストとそれを操作する関数
// リンクリストを生成する関数, 要素を任意の場所に挿入する関数,
//   すべての要素を順に標準出力に印字する関数
// 2019/05/25 櫛田一樹

#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

void MakeList(int n); //リスト作成
void InsList(int insnum); //リストへの挿入
void OutPutList(); //リストを出力する
void Del(); //リストの解放

struct LIST{
    int number;
    struct LIST *prev;
    struct LIST *next;
};

struct LIST *start;

int main(){
    int n,insnum;
    char ans;
    printf("リストを作成します。\n初期の要素数を入力してください。(2以上):");
    scanf("%d",&n);
    //入力値検査
    assert(n > 2);

    //リストの作成
    MakeList(n);

    //要素の挿入
    while(1){
        printf("要素を挿入しますか? [Y/N] : ");
        scanf("%*c%c",&ans);

        if(ans=='Y'||ans=='y'){
            //要素を挿入する場合
            printf("要素を挿入する箇所を指定してください : ");

            //バッファの中に残っている改行文字をクリア
            fflush(stdin);
            scanf("%d",&insnum);

            //入力値検査
            assert(insnum > 0 && insnum <= n);
            InsList(insnum);

        }else if(ans == 'N'||ans == 'n'){
            //要素の挿入を行わない場合
            break;

        }else{
            //想定値以外のキー入力があった場合
            printf("再入力してください\n");
            continue;

        }
    }

    //リストの全要素を出力
    OutPutList();

    //解放
    Del();
    
    return 0;
}


void OutPutList(){
    struct LIST *now;
    now = start;
    int i = 0;
    printf("---リストの全要素を出力します---\n\n");
    while(1){
        printf("%d番目の要素---\n",i+1);
        printf("  現在のアドレス= %p\n",now);
        printf("  number\t= %4d\n",now -> number);
        printf("  前\t\t= %p\n",now -> prev);
        printf("  次\t\t= %p\n",now -> next);
        putchar('\n');
        if(now -> next == NULL){
            break;
        }
        now = now -> next;
        i++;
    }
    printf("status : 出力完了\n全体の要素数 : %d\n",i+1);
}


void InsList(int insnum){
    struct LIST *now, *new; //現在注目している箇所(now),新しく生成した要素(new)

    now = start;

    //挿入する要素の生成
    new = malloc(sizeof(struct LIST));
    printf("挿入する要素のnumber : ");

    //バッファの中に残っている改行文字をクリア
    fflush(stdin);
    scanf("%d",&new -> number);
    //挿入箇所まで移動
    for(int i = 0; i < insnum-2; i++){
        now = now -> next;
    }
    
    //リストの挿入
    new -> next = now -> next; //newの次をnowの次のアドレスにする
    now -> next -> prev = new; //nowの次の要素の前のアドレスをnewにする
    now -> next = new; //nowの次をnewにする
    new -> prev = now; //newの前をnowにする


    /* ここでメモリ開放していたため想定していた動作にならなかった。 */
    // free(now);
    // free(new);

}


void MakeList(int n){
    struct LIST *p;
    int i; //ループ用

    for(i = 0;i < n;i++){
        //先頭の構造体の生成
        if(i == 0){
            p = malloc(sizeof(struct LIST));
            start = p;

            //ひとつ前のアドレスにNULLを代入
            p -> prev = NULL;
        
        }else{
            //次の構造体を生成
            p -> next = malloc(sizeof(struct LIST));

            //現在のアドレスを次のひとつ前のアドレスに代入
            p -> next -> prev = p;

            //次に移動
            p = p -> next;
        }

        //項目の入力
        printf("%d番目のLISTのnumber : ",i+1);
        //バッファの中に残っている改行文字をクリア
        fflush(stdin);
        scanf("%d",&p -> number);

        //リスト最後のnextにNULLを代入
        p -> next = NULL;

    }
}

void Del(){
    struct LIST *next;
    struct LIST *delete;
    
    //次の要素のアドレス
    next = start -> next;

    //NULLまでループ
    while(next != NULL){
        //削除ポインタの保存
        delete = next;
        //削除する要素の次のポインタを取得
        next = next -> next;

        //解放
        free(delete);
    }
}

--------C-2
私はまずリストというものについてほぼ何も知らなかったため、この問に回答するために、実際のコード例と共にリストがどういったもので、どのように実装すればよいのかを勉強することから始まった。
その過程で、リストについて以下の知識を得た。
・双方向リストはポインタで前後の要素のアドレスを記憶しているため前後を自由に行き来できる
・配列のように添字で管理できないのでランダムアクセスはできない
・リストは挿入や削除、追加が配列と比較して簡単にできる
という知識を得たので、早速プログラムを作成していこうと考えた。これらをすべて頭の中で考えるのは難しいと悟ったため、紙に図を描いて大まかなアルゴリズムを考えた。大まかに考えたところでプログラムで実装した。
そこでプログラムを作成する上で私は、大学の授業でアサーションについて習ったため、このプログラムでも活用した。入力値を監視し、不正な値が入力された場合にプログラムを強制終了させるものだ。不正値が入力され、プログラムが変な挙動を起こさないように対策した。また、リストの解放を行う関数を最後に実行するようにした。これは、mallocで動的に割り当てたメモリ領域を開放してやらないと他のプログラムがそのメモリ番地を利用することができなくなってしまうからである。

今回のプログラムは、最初実装したとき、リストに要素を挿入する関数のみ設計したとおりに動かなかった。具体的には挿入したデータとそのひとつ前のデータに変な値が格納されてしまった。(挿入されたデータには巨大な数字,そのひとつ前には0) 原因はInsList関数の最後でnewとnowの構造体ポインタ変数を開放していたからだった。malloc関数で動的にメモリを割り当てた場合、最後にメモリ解放をしなければいけないと考えていたため、なかなか間違えている箇所に気づかなかった。
間違えている箇所を探すために、まず私が行ったことは、挿入を行った場合と行わなかった場合で出力された結果がどのように想定の結果と変わるのかを比較した。これは、このプログラムの中で唯一InsList関数に入る場合と入らない場合で比較することが可能なためである。InsList関数に入って、要素の挿入を行った場合、先述のような結果となったが、InsList関数に入らず、挿入を一度も行わずに出力した場合、正常に出力されたため、リストの作成とリストを出力する関数、main関数には不具合はないと考えた。そのため、私の考えた、リストを交換するアルゴリズムとInsList関数のどちらかに不具合の原因が存在すると考え、両方のトレースを行った。
これは、私の考えたアルゴリズムが間違えているのか、それとも実装ができていないのかを明確にするためである。トレースの結果、リストに要素を挿入するアルゴリズムに不具合を見つけることはできなかった。InsListをトレースし、見つけた不具合の修正や、不要なコードをリファクタリングした。関数の処理の順番を変更してみたり、ポインタの切り替え部分をトレースし直してみたりした。出力時に現在のアドレスと、構造体に格納されている次のアドレスと前のアドレスを表示するようにした。その結果、リスト構造は正常に成立していることが確認できた。しかし、データは先述の通り正しく格納されていなかった。Webで「リスト 挿入」で検索し、いくつかのコード例を見ていたところ、関数の最後で解放していないことに気づいた。試しにコメントアウトしてみたところ、正常に動作した。


----選択問題S1----

--------S1.1
・拡張カードからチップセットの間を結ぶバスとして用いられる
・バス幅が32bitと64bitの二種類が存在する。パラレルバス。
・PCIバスの後継にPCI Expressバスが存在する。こちらはシリアルバスである。
・PCIバスは現在の家庭用コンピュータではほとんど後継のPCI Expressバスになっている。
・グラフィッボードやSSD、拡張カードを挿すスロットをPCIスロット、もしくはPCI Expressスロットという。
・PCI Expressスロットには 大きさによってx1, x4, x8, x16などに分かれており、それぞれ下位互換性を持っている。


--------S1.2
・PCI ExpressバスとPCIバスはソフトウェア互換性が存在する
・PCI Expressの世代によって帯域が異なる
・PCIバスの動作電圧は5V or 3.3Vである
・PCI Express は1レーンあたりの通信帯域が決められている。これをいくつか束ねてx16まで通信帯域を稼ぐことが可能である
・m.2はSATAとPCI Expressの両方をサポートしているが、どちらがしようされるかはマザーボードによって決まる
・PCIデバイスとCPU は制御や情報のやりとりを行うために両者で共有されたメモリにアクセスする必要がある。その共有メモリにはデバイスのレジスタの情報が含まれている。
・CPUのシステムメモリを共有メモリの代わりに使用することもできる。その場合、CPUは一時停止し、PCIデバイスが使用を完了するまで待たなければならない。その場合、メモリのアクセスも一度にひとつの機器に制限されるため、システムの処理速度が遅くなる。
・BAR(ベースアドレスレジスタ)は、デバイスが使用できるPC I/O空間とPCIメモリ空間のタイプと容量・位置を決定し、割り当てを行うために使用される。ベースアドレスレジスタはマイクロプロセッサ内部のレジスタの一種でメモリ上に展開されたある大きさのデータ・プログラムを扱う際に、その先頭のアドレスを格納するために用いられる。
・キーボード、マウス等の入出力デバイスがCPUを呼び出すときの割り込み要求のことをIRQ( Interrupt ReQuest)という。単にIRQと言った場合はPC/AT互換機でハードウェアがCPUに対して割り込み要求を通知する際の識別番号を意味する場合もある。
・PCIバスを使用すると複数の拡張カードでIRQを共有できる→IRQ不足を緩和できる。
・MSI(Message Signaled Interrupts)はデータをメモリに書き込むことで割り込みを発生させる割り込み方法の一種。デバイスは複数の割り込みを持つことができる。
・MSIの拡張としてMSI-xが存在し、以下の違いが存在する。
　→割り込み数が32から2048までのサポートできる数が増加している
　→MSIでの割り込み数が2のべき乗という制約がなくなった
　→MSIは割り込みは連続でなければならない制約がなくなった

・APICはx86アーキテクチャでの割り込みコントローラのこと
・従来のコントローラに対し、マルチプロセッサ対応、優先度制御などの機能が付加されている
・シリアルATAはATAの後継である。ATAがパラレル通信であったのに対し、SATAはシリアル通信である。
・現在、コンピュータに搭載されているSSDや光学ドライブ、HDDなどを接続する標準的なインターフェイスである。私が過去に組んだPCもHDD,SSD,光学ドライブなどがSATA接続である。
・SATAの拡張規格にeSATA(External Serial ATA)というものが存在する。SATAとのコネクタ形状に互換性はない。ホストPCの電源を入れたまま接続ケーブルの抜き差しができる「ホットスワップ機能」に対応している。専用ブートROMを搭載したeSATA対応マザーボード等と対応したハードドライブを組み合わせることで、UNIX系OSのみならず、Windowsのインストールの可能なマルチブート環境の構築を簡単に行える。これは信号変換での転送速度のロスが全く発生せず、SATAの持つメリットを最大限活かすことが可能である。そのため、USB3.0以降の規格が普及した現在でもマルチブート環境ユーザの間では、とても根強い人気がある。
・USB3.0によるPCと周辺機器の通信を制御するUSBコントローラの規格をxHCI( Extensible Host Controller Interface )という。Intelが自社のマザーボードに組み込むコントローラLSIの使用を定めたもの。事実上業界標準として扱われている。USB対応機器を開発する際はIntelからxHCIの仕様を入手し、それに適合するように製品を開発することが多い。USB2.0のコントローラはEHCI、USB1.1ではOHCIとUHCIの２通りが存在する。EHCIはOHCIとUHCIの２つを統一したものである。



--------S1.3
今回、PCIについて調べる際にWikipediaやIT用語辞典のほか、archive.linux.or.jpやXILINXのサイトや、はてなブログで解説されている記事などのWeb上のページを参照したほか、サークルの先輩や、大学の先生に聞いて、PCIバス等について調べた。また、高校のときに使用していたハードウェアの教科書やコンピュータシステム技術の教科書も参照した。


----共通問題D----

私が本格的にC言語を扱うようになったのは高校からだ。しかし、大学に入ってから、OSを自作した人や、競技プログラミングなど、様々な分野の方々に出会って、自分の世界が広がった。
そこで、今まで自分は学校の課題を解いていることがほとんどで、自分から積極的に何かを作ったことは今まで課題研究でのArduinoを使用したゲーム(自転車の後輪に発電機を取り付け、交流から直流に変換された電圧値をArduinoからPCに送ることでPC内のキャラクターを操作するゲーム)、Javaで少人数でのチームで開発したおよそ800行程度のパズル＆ドラゴンズ風のゲームなど、OSではなく、OS上で動くアプリケーションのものしか作ったことがなかった。大学に入り、自分の世界が広がり、OSを自分で作ることができると知ったことで「オリジナルのOSを作ってみたいな」と考えるようになった。
オリジナルのOSを作りたいと思っていたことや、自分の成長のためにこのキャンプに応募した。
これまで、プログラムを組む上で問題に出会ったときは、Webを調べるだけでとどまっていたが、今回PCIバスについて調べるときに大学の先輩や先生に相談してみることも大事だと気づいた。
私は、自分の所属しているサークルから、「30日でできる! OS自作入門」を借りているため、このキャンプの合否にかかわらず、この応募課題を提出してから始めたいと考えている。
最後に、なかなかこのキャンプに参加する勇気の出なかった私の背中を押してくださった講師陣の方々をはじめとした皆さんに心から御礼を申し上げるとともに、キャンプに参加した際はぜひよろしくお願い申し上げる。
